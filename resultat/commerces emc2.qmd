```{r, include=FALSE}
ofce::init_qmd()
legend_h <- list(
  theme_ofce_void(), 
  theme(
    legend.position = "bottom",
    legend.box.spacing = unit(3, "pt"),
    legend.title = marquee::element_marquee(vjust=1.2, margin = margin(t=0, b=0, r=6)),
    legend.text = marquee::element_marquee(size = rel(0.6), margin = margin(t=1, b=1), width = NULL, hjust=0.5),
    legend.text.position = "bottom", 
    legend.key.spacing.x = unit(1, "pt"),
    legend.key.height = unit(6, "pt") ) )

```


# Motif commerce dans l'Enquête Mobilité Certifiée Cerema

## Proximité et EMC^2^

On injecte les indicateurs d'accès aux commerces (les 4 types) ainsi que deux indicateurs de densité (densité simple et pondérée par la population) dans les zones de résidence de l'EMC^2^ AMP. On peut alors confronter les distances parcourues en voiture à la valeur moyenne des indicateurs sur chacune des zones. Le graphique indique une nette corrélation négative pour les 6 indicateurs retenus, ici découpés en quantile. Ce type de graphique permet de calibrer l'indicateur sur la distance parcourue.

```{r}
#| label: fig-emc2alim
#| fig-cap: Distance parcourue par décile de proximité aux aménités
#| fig-asp: 1

data_emc2 <- source_data("commerces/data_emc2.R")

ggplot(data_emc2$d |> filter(!is.na(q), n>10))+
  aes(x = q, y = d_car, color = type) +
  facet_wrap(vars(type), ncol = 2, labeller = as_labeller(data_emc2$labels)) +
  scale_color_manual(values = c("skyblue2", "skyblue3", "skyblue4", "skyblue1", "orange2", "orange3")) + 
  geom_boxplot(outliers = FALSE, show.legend = FALSE, linewidth = 0.25) + 
  xlab("décile de population classée selon la proximité") +
  ylab("Distance parcourue moyenne pour les courses en voiture")+
  theme_ofce() +
  ofce_caption(
    source = "EMC^2^, C200, Fichiers fonciers, calculs des auteurs",
    note = "On définit les déciles de proximité par rapport à la population, classée par proximité. Le premier décile de proximité est donc celui pour lequel les 10% de la population le moins proches des commerces ou des services sont. Les boites à moustache représentent à l'intérieur d'un décile de proximité la diversité des distances parcourues.")

```

On confirme cette analyse en effectuant des régressions (log)linéaires en utilisant les déciles des indicateurs en variables explicatives. 3 variables de contrôle ont été ajoutées (revenu par unité de consommation moyen de la zone (en log), part des individus avec enfants dans la population, part des actifs occupés dans la population). Les résultats confirment les éléments déjà vus. Les zones de résidence qui comportent moins de 10 individus sondés par l'EMC^2^ sont exclues de l'analyse sans que cela ne modifie véritablement les résultats.

1.  les indicateurs des différentes aménités (regroupées en 4 grandes catégories) sont très proches en termes d'explication de la distance parcourue en voiture. La densité ou la densité pondérée expliquent également les distances parcourues en voiture, avec quelques nuances (par exemple, le revenu ne joue plus). Les variables de contrôle (part des individus avec enfants, part des actifs occupés) sont significatifs, d'un signe interprétable et assez constants parmi les variables expliquées.

2.  La distance parcourue décroît nettement avec l'accessibilité aux commerces ou la densité. Ce résultat important valide la construction de ces indicateurs et permet de les calibrer. Par ailleurs, l'effet trouvé est important, puisque entre le premier décile d'accès aux aménités (en gros pas d'aménités accessibles à pied en moins de 15 minutes) et le dernier (zones très denses et très dotées) est de l'ordre de 4 (entre ×4,3 et ×3,1 suivant les indicateurs)[^commerces-4].

3.  Les coefficients estimés permettent éventuellement de distinguer des catégories d'accessibilité, en regroupant les déciles quant ils ont des coefficients proches. En se basant sur l'indicateur pour les commerces alimentaires, les 3 premiers déciles peuvent être regroupés en une seule catégorie où l'accessibilité aux aménités n'est pas assez élevée pour empêcher l'utilisation de la voiture. D'après le @fig-lorenz, cela correspond à un niveau de proximité moyen aux commerces alimentaires d'environ 32 (surface équivalente) ce qui est relativement élevé : en moyenne la diversité y atteint 5,7, soit un peu plus de la moitié de la diversité maximale et la surface brute est de l'ordre de 500 m² de surface commerciale. C'est quelque chose qui correspond à 3 commerces alimentaires. On peut ensuite inclure les 3 déciles suivants, pour un effet de réduction de 1,5 des distances parcourues et les 4 derniers déciles, avec une distinction possible pour le dernier décile. Cette catégorisation illustre le calibrage que permet l'analyse de régression.

[^commerces-4]: Cette valeur se lit sur le tableau en prenant le coefficient du dernier décile, moins celui du premier (égal à 0 par référence) et en élevant $e$ à la puissance de cette différence.

Les observation du modèle estimé sont les zones EMC^2^, indexées par $i$, où le nombre d'individus sondés (présent dans l'EMC^2^) est supérieur à 10. L'équation du modèle est :

$$
log(d_i) = a \times log(rev_{uc,i}) + b \times p_{enf,i} + c \times p_{act,i} + d_k \times \mathcal{P}_{i,k} + e + \varepsilon_i
$$

où les $k$ sont les quantiles, pondérés par la population, de l'indicateur de proximité (ainsi le premier quantile vaut 1 pour les 10% de la population qui ont la proximité la plus faible). Le premier décile est la valeur de référence et n'est pas estimé.

```{r}
resemc2 <- source_data("commerces/regresemc2.R")
```

::::: {#fig-regresemc2}
:::: panel-tabset
## Graphique

::: column-margin
```{r}
margin_link(resemc2$res, "residus_emc2_MetAMP", "résidus des régressions de distance")

```
:::

```{r}
#| fig-asp: 1
#| cache: FALSE

gg <- resemc2$res |> 
  select(mod, starts_with("qd"), starts_with("se_qd")) |> 
  mutate(qd1 = 0, se_qd1 = 0) |> 
  rename_with(.cols = starts_with("qd"), ~str_c("q_", .x)) |> 
  pivot_longer(cols = c(starts_with("q_qd"), starts_with("se_qd")),
               names_sep = "_", 
               names_to = c("type", "dec")) |> 
  mutate(
    dec = dec |> str_remove("qd"),
    dec = str_c("d", dec) |> factor(str_c("d", 1:10)),
    mod = factor(mod, c("Alimentaire", "Com. non alim.", "Bars, ...", "Santé humaine", "Densité", "Densité pondérée"))) |> 
  pivot_wider(id_cols = c(mod, dec), names_from = type, values_from = value) |> 
  mutate(
    qmin = exp(q - 2*se),
    qmax = exp(q + 2*se),
    q = exp(q)) |> 
  arrange(mod, dec) |> 
  left_join(resemc2$dmc2, by = c("mod", "dec")) |> 
  mutate(tooltip = glue("<b>{mod}</b><br>décile : {dec}<br>{round(q*100, 1)}% du décile d1<br>Observé : {round(q_data*100)}% du décile d1")) |> 
  ggplot() + 
  facet_wrap(vars(mod), ncol = 2) +
  geom_pointrange_interactive(
    aes(x = dec, y = q, ymin = qmin, ymax = qmax, color = mod, tooltip = tooltip, data_id = dec),
    hover_nearest = TRUE) + 
  geom_point(
    aes(x = dec, y = q_data, color = mod),
    position = position_nudge(x= 0.25), shape = 5)+
  scale_color_manual(values = c("skyblue2", "skyblue3", "skyblue4", "skyblue1", "orange2", "orange3"), name = NULL) + 
  xlab("Déciles de population classée par proximité")+
  ylab("Effet relatif au d1") +
  guides(color = "none") +
  ofce_caption(
    source = "EMC^2^ AMP, C200, Fichiers Fonciers, calculs des auteurs", 
    note = "Le graphique présente l'effet relatif au premier décile de proximité d'un autre décile de proximité sur les distances parcourues pour le motif courses. Ainsi, pour le dernier décile de proximité aux commerces aliementaires, le modèle estimé prévoit des distances parcourues 0,18 fois celles du décile d1. Le losange représente la valeur moyenne observée pour le décile de proximité d'après l'EMC^2^ AMP.") +
  theme_ofce()

gg |> girafy()
```

## Tableaux

```{r}
#| column: body-outset-right
#| cache: FALSE

resemc2$tbl |> 
  gt() |>
  fmt_markdown(c(r.squared, adj.r.squared,rev_uc, enfants, actoccup,
                 c, se, d1,d2,d3,d4,d5,d6,d7,d8,d9,d10)) |> 
  fmt_percent(c(r.squared, adj.r.squared), decimals = 1) |> 
  cols_label(r.squared = md("*R^2^*"), adj.r.squared = md("*adj. R^2^*"), 
             c = "constante", mod = "", rev_uc = md("rev~uc~")) |> 
  tab_options(
    table.font.size = 9) |> 
  cols_align("left", 1) |> 
  cols_align("center", -1) |> 
  cols_hide(c(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10, 
              qd1,qd2,qd3,qd4,qd5,qd6,qd7,qd8,qd9,qd10) ) |> 
  tab_footnote(md("Le coefficient *se* est estimé avec un modèle où les déciles de proximité sont remplacés par le logarithme de la proximité et identique pour les autres facteurs."), locations = cells_column_labels(se))
```

```{r}
#| column: page-inset-right
#| cache: FALSE

resemc2$tbl |> 
  gt() |>
  fmt_markdown(c(r.squared, adj.r.squared,rev_uc, enfants, actoccup,
                 c, se, d1,d2,d3,d4,d5,d6,d7,d8,d9,d10)) |> 
  fmt_percent(c(r.squared, adj.r.squared), decimals = 1) |> 
  cols_label(r.squared = md("*R^2^*"), adj.r.squared = md("*adj. R^2^*"), 
             c = "constante", mod = "", rev_uc = md("rev~uc~")) |> 
  tab_options(
    table.font.size = 9) |> 
  cols_align("left", 1) |> 
  cols_align("center", -1) |> 
  cols_hide(c(r.squared, adj.r.squared, nobs, rev_uc, enfants, actoccup, c, se) ) |> 
  cols_nanoplot(starts_with("qd"), plot_type = "bar", new_col_name = "deciles") |> 
  cols_label(deciles = "déciles") |> 
  cols_align("left", 1) |> 
  cols_align("center", -1) 

```
::::

Modèles de régression sur les zones de l'EMC^2^
:::::

## Densité inversée

A partir des données de distance (ou de temps de parcours), de la localisation des résidents et des localisations des aménités, on peut construire un indicateur dit de "densité inversée" par lequel on représente pour chaque carreau la population qu'on peut atteindre soit à 15 minutes de marche ou de transport en commun, soit à 30 minutes de voiture.

```{r}
#| label: fig-densinv
#| fig-cap: "Densité inversée, 15 minutes marche à pied et TC et 30 minutes en voiture"
#| fig-asp: 1

dens_inv <- bd_read("dens_inv") |> 
  group_by(idINS) |>
  summarize(
    scot = first(scot),
    si_w = first(si_w),
    si_c = first(si_c)) |> 
  filter(!is.na(si_w)|!is.na(si_c)) |> 
  mutate(
    qsiw = as.numeric(cut(si_w, quantile(si_w, probs = 0:5/5, na.rm=TRUE), include.lowest = TRUE)),
    qsic = as.numeric(cut(si_c, quantile(si_c, probs = 0:5/5, na.rm=TRUE), include.lowest = TRUE))) |> 
  select(idINS, qsic, qsiw, scot) |> 
  ungroup() |> 
  pivot_longer(cols = c(qsic, qsiw))  |> 
  drop_na() |> 
  mutate(value = factor(value),
         name = factor(name, c("qsiw", "qsic"), c("Marche ou TC (15 min.)", "Voiture (30 min.)"))) |> 
  r3035::sidINS2sf()

bb <- bd_read("communes") |> 
  filter(INSEE_COM %in% c("13028", "13088", "13050", "13048")) |>
  st_transform(3035) |> 
  st_bbox()

ggplot() +
  bd_read("decor_carte") +
  geom_sf(
    data = dens_inv |> filter(scot),
    mapping = aes(fill = value, color = value), linewidth = 0.1) + 
  scale_fill_paletteer_d("fishualize::Bodianus_rufus", 
                         direction=1, 
                         label = c("faible", "", "", "", "élevée"), name = "Densité inversée :")+
  scale_color_paletteer_d("fishualize::Bodianus_rufus", 
                          direction=1, 
                          label = c("faible", "", "", "", "élevée"), name = "Densité inversée :")+
  facet_wrap(vars(name)) +
  coord_sf(xlim = c(bb$xmin, bb$xmax), ylim = c(bb$ymin, bb$ymax), crs = st_crs(3035)) +
  legend_h +
  theme(plot.caption = element_marquee(margin = margin(t=0,b=0))) +
  ofce_caption(
    source = "C200, Fichiers fonciers, OSM, cacluls des auteurs", 
    note = "La densité inversée consiste à évaluer le nombre d'habitants que l'on peut ateindre en partant d'un carrean en un temps et un mode donné. Le ratio moyen entre la marche à pied/TC 15 minute et la voiture 30 min est de 0,033.")

```

## Projection des distances et estimation des émissions de CO~2~ spatialisées

Partant des comportements individuels observés dans l'enquête EMC^2^, nous avons modélisé les distances parcourues en voiture pour effectuer des courses. Cette modélisation est en deux temps : tout d'abord, nous avons effectué une régression logistique pour estimer la probabilité d'un individu d'effectuer un jour donné des courses en prenant sa voiture. Puis, dans le cas où il fait des courses ce jour-là, en voiture, nous avons estimé par une régression simple la distance qu'il parcourt pour l'ensemble des courses effectuées dans la journée. Ces modèles, qui ont vocation à être emboîtés, prennent comme variables explicatives d'un côté une information spatiale, la proximité des commerces mesuré à partir, ici, de l'indicateur de proximité des commerces alimentaires, et d'un autre côté des informations socioéconomiques sur l'individu observé, disponibles à la fois dans l'enquête EMC^2^ et localisable au carreau 200m. Ces variables sont le niveau de vie, le fait d'être ou non en couple, le fait d'avoir ou non des enfants et, enfin, le statut d'occupation (actif occupé ou non).

Le premier modèle est la régression logistique suivante :

$$
\begin{aligned}
logit(P(c_{car}=1)) = & \alpha \times \mathcal{P}_k + \beta \times rev_{uc} \\
& + \gamma_C \times \mathcal{I}_C + 
\gamma_E \times \mathcal{I}_E + \gamma_A \times \mathcal{I}_A + \delta
\end{aligned}
$$

où $P(c_{car}=1)$ est la probabilité de faire un ou plusieurs déplacements en voiture pour le motif "course" le jour de l'enquête, $\mathcal{P}_k$ est la proximité en déciles pondérés par la population, $rev_uc$ le revenu par unité de consommation, $\mathcal{I}_C$, $\mathcal{I}_E$, $\mathcal{I}_A$ sont des indicatices pour respectivement les individus en couple, avec un ou plusieurs enfants et actif occupé (un chômeur n'est pas un actif occupé).

```{r}
#| label: tbl-logitcourse
#| tbl-cap: Régression logistique sur la probabilité de faire ses courses en voiture

MOD_freq <- bd_read("Mod frequence courses")

library(gtsummary)

tbl_regression(
  MOD_freq, exponentiate = TRUE,
  label = list(se_dec = "Proximité des commerces (déciles)",
               couple = "En couple",
               enfant = "Avec enfant(s)",
               ACTOCCUP = "Actif occupé",
               revenus_hab = "Niveau de vie (en euros)"),
  estimate_fun = label_style_ratio(digits = 3)) |>
  modify_header(label = "**Variable**", estimate = "**Coefficient**", conf.low = "**IC à 95%**", p.value = "**P**") |>
  modify_footnote(everything() ~ NA, abbreviation = TRUE)

```

Le second modèle estime la distance totale parcourue en voiture d'un enquêté qui a fait, le jour observé, au moins une course en voiture. Il s'écrit comme suit :

$$
\begin{aligned}
log(d_{car}) = & \alpha^d \times \mathcal{P}_k + \beta^d \times rev_{uc} \\ 
& + \gamma_C^d \times \mathcal{I}_C + \gamma_E^d \times \mathcal{I}_E + \gamma_A^d \times \mathcal{I}_A + \delta^d + \varepsilon
\end{aligned}
$$

où $d_{car}$ est la distance parcourue en voiture si il y a eu déplacement, et les mêmes notations que pour le modèle précédent.

```{r}
#| label: tbl-regdistance
#| tbl-cap: Régression sur la distance parcourue en voiture pour faire ses courses

MOD_dist <- bd_read("Mod distance courses")

tbl_regression(MOD_dist,
               label = list(se_dec = "Proximité des commerces (déciles)",
                            couple = "En couple",
                            enfant = "Avec enfant(s)",
                            ACTOCCUP = "Actif occupé",
                            revenus_hab = "Niveau de vie (en euros)"),
               estimate_fun = label_style_ratio(digits = 3)) |>
  modify_header(label = "**Variable**", estimate = "**Coefficient**", conf.low = "**IC à 95%**", p.value = "**P**") |> 
  modify_footnote(conf.low = NA, abbreviation = TRUE)

```

Une fois les modèles estimés et emboîtés, nous pouvons projeter leur estimation au carreau 200m en suivant la méthode déployée dans @meaps2024a. Pour chaque carreau, on projette la prédiction de comportement pour chaque catégorie de ménage (dans chaque carreau, il y a 8 catégories de ménages) et on fait la moyenne des distances projetées par carreau pondérée par la proportion de chaque catégorie dans le carreau. Le niveau de vie n'est connu qu'en moyenne au carreau, il est donc appliqué à toutes les catégories de ménage du carreau. Puis on applique un coefficient fixe pour estimer le niveau de CO~2~ émis par individu et par an au motif commerce.

```{r}
#| label: fig-proj
#| fig-cap: Estimation du CO~2~ par individu pour le motif course projetté au carreau 200m
#| fig-asp: 1

proj <- bd_read("projection") |> 
  r3035::sidINS2sf() |> 
  mutate(
    wqdist = santoku::chop_quantiles(dist, weights = ind, probs = 0:5/5)
  )

labels_co2 <- proj |> 
  st_drop_geometry() |> 
  group_by(wqdist) |> 
  summarize(co2 = MetricsWeighted::weighted_mean(dist, w = ind) * 365 * 218/1000000 ) |> 
  pull(co2) |> 
  round(2) |> 
  str_replace("\\.", ",") |> 
  str_c(" tCO{.sub 2}")

ggplot() +
  bd_read("decor_carte") +
  geom_sf(
    data= proj,
    mapping= aes(fill = wqdist, col = wqdist), linewidth = 0.1) + 
  scale_fill_paletteer_d(palette = "fishualize::Bodianus_rufus", 
                         direction=1, 
                         label = labels_co2, 
                         name = "Emissions commerce par individu par an :")+
  scale_color_paletteer_d(palette = "fishualize::Bodianus_rufus", 
                          direction=1, 
                          label = labels_co2, 
                          name = "Emissions commerce par individu par an :")+
  legend_h +
  ofce_caption(
    source = "C200, Fichiers Foncier, EMC^2^. Calculs des auteurs, version 1.0")

```

::: column-margin
```{r}
data <- proj |> 
  select(idINS, ind, freq, dist) |> 
  mutate(idINS = r3035::expand_idINS(idINS),
         co2_pi =  dist * 365 * 218/1000000 ) |> 
  select(idINS, ind, co2_pi) |> 
  st_drop_geometry() 

margin_link(
  data,
  "co2_motif_commerce_MetAMP.csv",
  "données CO2 pour le motif courses")

```
:::

## Emissions de CO~2~ et niveau de vie

De la même façon que pour les mobilités professionnelles, l'analyse conduite ici permet d'analyser le lien entre niveau de vie[^commerces-5] et émissions de CO~2~ pour le motif commerce. La structure du territoire de la métrople d'Aix-Marseille-Provence influe ici aussi ce lien : Plus le niveau de vie est élevé, plus les émissions sont importante, un doublement du niveau de vie étant associé à un peu moins qu'un doublement des émissions (l'élasticité est de 0,78, donc un doublement du niveau de vie est associé à une mulitplication par 1,56 des émissions).

[^commerces-5]: Le niveau de vie est le revenu disponible net (intégrant les différents revenus, les prestations moins les impôts sur le revenu) divisé par les unités de consommation. Les unités de consommation tiennent compte des économies d'échelles réalisées par la vie à plusieurs mais également des charges liées à une structure familale plus importante. Deux apporteurs de revenus ont un niveau de vie supérieur en ménage plutôt que séparés. Un apporteur de revenu à un niveau de vie inférieur lorsqu'il ou elle a des enfants à charge.

```{r, include = FALSE}
label_iris <- bd_read("iris22") |> 
  st_drop_geometry() |> 
  select(iris = CODE_IRIS, labiris = LIB_IRIS, labcom = LIBCOM, com = DEPCOM)

densite <- proj |> 
  st_drop_geometry() |> 
  mutate( co2_pi =  dist * 365 * 218/1000000,
          co2 = co2_pi * ind ) |> 
  select(idINS, ind, co2_pi, co2) |> 
  left_join( bd_read("c200ze") |> 
               st_drop_geometry() |> 
               select(idINS, dep, com = com22, iris = IRIS),
             by = "idINS")

prix_iris <- bd_read("km_iris") |> 
  select(iris = IRIS, prix, shape, dens.alt=dens, co2_p = co2_i, snv) |> 
  left_join(label_iris, by = "iris")

co2_iris <-  densite |> 
  group_by(iris) |> 
  summarize(co2_pi_c = sum(co2)/sum(ind),
            dens = sum(ind)/4/n(),
            pwd = sum(ind^2)/4/sum(ind),
            ind = sum(ind),
            n = n()) |> 
  left_join(prix_iris, by = "iris") |> 
  mutate(
    co2_pi_p = co2_p/ind,
    tooltip2 = glue(
      "<b>{labiris}</b>
      {labcom}
      Emissions motif commerce : {round(co2_pi_c,2)} tCO<sub>2</sub>/an
      Densité : {round(dens)} hab/ha
      Prix de l'immobilier (achat ancien) en 2022 : {euro(prix)}/m²
      Niveau de vie moyen : {euro(snv)}/an/uc" ) )

legend_c <- list(
  theme(
    plot.margin = margin(),
    legend.position = "bottom", 
    legend.text = element_blank(),
    legend.spacing = unit(3, "cm"),
    legend.justification = c(1,0.5)),
  theme(
    legend.direction = "horizontal",
    legend.key.width = unit(24,"pt"),
    legend.text = element_text(hjust=0.5, size = rel(0.5)),
    legend.title = element_marquee(hjust=1),
    legend.axis.line = element_line(linewidth = 0.1)),
  guides(
    shape = "none", 
    size = guide_circles(
      override.aes = list(colour = "black", shape=21, stroke = 0.25),
      theme = theme(
        legend.text = element_text(hjust=0.5, size = rel(0.5)),
        legend.justification.bottom = "right")),
    fill = guide_colorbar(
      theme = theme(
        legend.title = element_marquee(vjust = -0.5),
        legend.ticks.length = unit(12, 'pt'),
        legend.ticks = element_line(linewidth = .25, colour = "white"),
        legend.justification.bottom = "left"
      ))))

```

```{r}
#| label: fig-co2_c_ndv
#| fig-cap: Emissions CO~2~ commerce et niveau de vie
#| fig-asp: 0.8

base <- ggplot(co2_iris) +
  aes(x=snv, y=co2_pi_c, fill = prix, weights=ind) +
  scale_fill_distiller(palette="Spectral", 
                       trans="log", direction = -1,
                       oob = scales::squish,
                       limits = c(1000, 8000),
                       aesthetics = c( "fill"),
                       breaks = c(1000, 2000, 4000, 8000),
                       name="prix immobilier\n€/m² 2022")+
  geom_point_interactive(
    aes(size = dens, shape = shape, tooltip = tooltip2),
    hover_nearest = TRUE,
    alpha=0.95, stroke=0, color = "transparent") +
  scale_shape_manual(
    values=c("Marseille"=22, "Aix-en-Provence"=23, "autre"=21)) +
  scale_x_continuous(
    "Niveau de vie moyen de l'IRIS", 
    labels = scales::label_number(big.mark = " "), 
    limits = c(15000, 35000)) + 
  scale_y_continuous(
    "tCO{.sub 2}, motif commerce (moyenne de l'IRIS)",
    labels = scales::label_number(big.mark = " ")) +
  scale_size(
    name = "Individus/ha", 
    breaks = c(100, 500), 
    guide = "circles", 
    range = c(.5, 8)) +
  geom_smooth(col="lightblue", fill = "lightblue1", aes(weight = ind)) +
  theme_ofce(base_size = 10) +
  legend_c +
  ofce_caption(
    source = "C200, Fichiers Foncier, EMC^2^. Calculs des auteurs, version 1.0",
    note = "Chacun des points représente un IRIS. Les carrés sont pour la commune de Marseille, les losanges pour la commune d'Aix-en-Provence, les ronds pour les autres communes.")

top_dens <- ggplot(co2_iris)+
  geom_density(aes(x=snv, y=after_stat(density), weight=ind), 
               color = "black", fill="pink", alpha=0.25, linewidth=0.2)+
  theme_ofce_void()+
  theme(plot.margin = margin())
right_dens <- ggplot(co2_iris)+
  geom_density(aes(x=co2_pi_c, y=after_stat(density), weight=ind), 
               color = "black", fill="pink", alpha=0.25, linewidth=0.2)+
  coord_flip()+
  theme_ofce_void()+
  theme(plot.margin = margin())

pp <- patchwork::wrap_plots(
  top_dens, patchwork::plot_spacer(), base,  right_dens,
  ncol=2, nrow=2, widths = c(1, 0.1), heights = c(0.1, 1)) &
  theme(panel.spacing = unit(0, "pt"))

girafy(pp)
```

::: column-margin
```{r}
margin_link(co2_iris |> select(-dens.alt, -shape, -tooltip2), "CO2_commerces_IRIS", "Données CO2 commerce à l'IRIS")
```
:::

## Emissions de CO~2~ et densité

Nous reproduisons ici le [graphique reliant émissions pour la mobilité professionnelle](trajets.qmd#fig-co2dens) et densité pour les émissions liées au motif commerce. Comme dans ce graphique, chaque point est un IRIS. La couleur des points dépend du prix de l'immobilier en 2022, la taille du nombre d'individus résidant dans l'IRIS. Sur le côté droit et au dessus sont rappelés les densités (i.e. le nombre d'individus en haut, les émissions à droite) correspondant respectivement à l'axe des x et des y. Ces densités permettent d'identifier où se trouve la majorité de la population ou où sont émises la majorité des émissions.

On observe une relation globalement décroissante entre émissions de CO~2~ pour le motif commerce et densité. Ce résultat est un corrolaire en grande partie des résultats précédents. On a vu que la densité de commerces (et donc l'indicateur de proximité des commerces) est étroitement liée à la densité de population. Or les émissions dépendent, d'après la modélisation retenue et calibrée sur l'EMC^2^ d'Aix-Marseille-Provence, de l'indicateur de proximité, entre autres variables explicatives. On retrouve donc ici le lien.

On peut remarquer quelques différences avec le graphique relient densité et émissions pour le motif professionnel : la plage de variation des émissions pour le motif commerce est bien plus petite (attention cependant le [graphique pour le motif professionnel](trajets.qmd#fig-co2dens) est en tCO~2~/actif et non par individu, voir plus bas @sec-compprocom pour une comparaison directe) ; les masses d'émissions n'ont pas, contrairement au motif professionnel, une allure bimodale. Cela traduit une répartition plus homogène des situations et traduit également l'émergence "spontanée" de commerces là où il y a de la densité.

```{r}
#| label: fig-dens_c
#| fig-cap: Emissions CO~2~ commerce versus densité (iris)
#| fig-asp: 0.8

base <- ggplot(co2_iris) +
  aes(x=dens, y=co2_pi_c) +
  scale_fill_distiller(palette="Spectral", 
                       trans="log", direction = -1,
                       oob = scales::squish,
                       limits = c(1000, 8000),
                       aesthetics = c( "fill"),
                       breaks = c(1000, 3000, 8000),
                       name="prix immobilier (IRIS)\n€/m² 2022")+
  geom_point_interactive(
    aes(size = dens, fill = prix, shape = shape, tooltip = tooltip2),
    hover_nearest = TRUE,
    alpha=0.95, color="transparent", stroke=0) +
  scale_shape_manual(
    values=c("Marseille"=22, "Aix-en-Provence"=23, "autre"=21)) +
  scale_x_continuous(
    "Individus/ha", 
    labels = scales::label_number(big.mark = " "),
    limits = c(0,400)) + 
  scale_y_continuous(
    "tCO{.sub 2}, motif commerce (moyenne de l'IRIS)", 
    labels = scales::label_number(big.mark = " ")) +
  scale_size(
    name = "Individus/ha", 
    breaks = c(100, 500), 
    guide = "circles", 
    range = c(.5, 8)) +
  geom_smooth(col="gold3", fill = "gold", aes(weight = ind), alpha=0.1) +
  theme_ofce(base_size = 10)+
  legend_c + 
  ofce_caption(
    source = "C200, Fichiers Foncier, EMC^2^. Calculs des auteurs, version 1.0",
    note = "Chacun des points représente un IRIS. Les carrés sont pour la commune de Marseille, les losanges pour la commune d'Aix-en-Provence, les ronds pour les autres communes."
  )

top_dens <- ggplot(co2_iris)+
  geom_density(aes(x=dens, y=after_stat(density), weight=ind), 
               color = "black", fill="gold", alpha=0.25, linewidth=0.2)+
  theme_ofce_void()+
  theme(plot.margin = margin())

right_dens <- ggplot(co2_iris)+
  geom_density(aes(x=co2_pi_c, y=after_stat(density), weight=ind), 
               color = "black", fill="gold", alpha=0.25, linewidth=0.2)+
  coord_flip()+
  theme_ofce_void()+
  theme(plot.margin = margin())

ppp <- patchwork::wrap_plots(
  top_dens, patchwork::plot_spacer(), base,  right_dens,
  ncol=2, nrow=2, widths = c(1, 0.1), heights = c(0.1, 1)) &
  theme(panel.spacing = unit(0, "pt"))

girafy(ppp)
```

::: column-margin
```{r}
margin_link(co2_iris |> select(-dens.alt, -shape, -tooltip2), "CO2_commerces_IRIS", "Données CO2 commerce à l'IRIS")
```
:::

## Comparaison des émissions liées au commerce et à la mobilité professionnelle {#sec-compprocom}

Le @fig-comp représente la corrélation entre la mobilité professionnelle et la mobilité pour le motif commerce. Chaque hexagone est coloré en fonction de la population ayant les mêmes émissions au titre de chacun des motifs. Le graphique peremt donc de visualiser la corrélation entre les émissions de CO~2~ pour les deux motifs et d'apprécier la population concernée.

Le graphique fait apparaître 3 éléments principaux :

1.  La corrélation entre les émissions pour les deux motifs est positive. Une régression (log-linéaire, pondérée) indique un coefficient de corrélation de 55%. Ce résultat était attendu, mais la corrélation est loin d'être élevé, ce qui veut dire que les lieux de vie, qui conditionnent les émissions pour les motifs commerce, ne sont pas nécessairement ceux qui donnent la plus grande accessibilité (qui réduit les émissions pour le motif professionnel quotidien).

2.  les émissions pour le motif professionnel sont plus élevées en moyenne et dans une plage plus dispersée que les émissions pour le motif commerce. toujours à partir d'une régression (log linéaire, pondérée) il y a un rapport de 1 à 2,3 entre les deux motifs.

3.  Les émissions pour le motif commerce sont bornées (le minimum observé est de 0,17 tCO~2~ par an par individu). Rappelons que la méthode propose une estimation de la valeur moyen par carreau (il n'y a donc pas de carreau dans lequel personne n'a de voiture, ni n'utilise jamais sa voiture pour les courses), alors que pour le motif mobilité professionnelle, certains carreaux, bien que peu nombreux, se voient imputé une valeur presque nulle des émissions. Ce résultat découle en partie de la méthode choisie (qui n'identifie pas, par exemple, les écarts à la routine domicile travail) et en partie découle des données.

```{r}
#| label: fig-comp
#| fig-cap: Mobilité professionnelle quotidienne versus mobilité pour le motif commerce
#| fig-asp: 0.8

pro <- bd_read("meaps_from") |> 
  st_drop_geometry() |> 
  select(idINS = fromidINS, 
         co2_pi_p = co2_pi)

comp <- bd_read("projection") |> 
  select(idINS, ind, dist) |> 
  mutate(co2_pi_c = dist * 365 * 218/1000000) |> 
  select(-dist) |> 
  left_join(pro, by = "idINS")

moy <- comp |> 
  summarize(co2_c = sum(co2_pi_c * ind, na.rm=TRUE),
            co2_p = sum(co2_pi_p * ind, na.rm=TRUE),
            ind = sum(ind)) |> 
  mutate(co2_pi_c = co2_c/ind,
         co2_pi_p = co2_p/ind)

tlt <- function(x) str_c(formatC(x, format = "f", big.mark=" ", digits = 0), " individus")

ggg <- ggplot(comp) +
  aes(x= co2_pi_p, y = co2_pi_c) +
  geom_hex_interactive(
    aes(weight = ind, tooltip = tlt(after_stat(count))), 
    hover_nearest = TRUE, binwidth = c(.025, .025)) +
  coord_equal(xlim = c(0,1.5), ylim=c(0,.75)) +
  scale_fill_gradient(
    name = "Individus:",
    low = "gray95", high = "steelblue", transform = "sqrt",
    breaks = c(1000, 10000, 30000), labels = c("1k", "10k", "30k")) + 
  xlab("Emissions par individu pour le motif professionnel (tCO2/individu/an)") +
  ylab("Emissions par individu pour le motif commerces (tCO2/individu/an)") +
  geom_hline(yintercept = moy$co2_pi_c, linetype = "dotted", color = "darkblue") +
  geom_vline(xintercept = moy$co2_pi_p, linetype = "dotted", color = "darkblue") +
  guides(
    fill=guide_colorbar(
      theme=theme(legend.key.width = unit(4,"cm"),
                  legend.text = element_text(hjust=0.5),
                  legend.title = element_marquee(hjust=1)))) + 
  theme_ofce(
    legend.text = element_blank(),
    legend.direction = "horizontal",
    legend.position = c(0.95, 0.95),
    legend.justification = c(1,1),
    legend.key.width = unit(24, "pt"), 
    legend.ticks.length = unit(9, "pt"),
    legend.title = element_marquee(vjust=-0.5)) +
  theme(
    legend.text = element_text(size = rel(0.5)) ) +
  ofce_caption(source = "C200, Fichiers Foncier, EMC^2^, MEAPS. Calculs des auteurs, version 1.0", ofce = FALSE)

girafy(ggg)
```

::: column-margin
```{r}
margin_link(co2_iris |> select(-dens.alt, -shape, -tooltip2, -co2_p), "CO2_commerces_IRIS", "Données CO2 commerce à l'IRIS")
```
:::