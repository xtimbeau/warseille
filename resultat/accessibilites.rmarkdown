```{r init, include=FALSE}
source("init.R")
```


# Calcul des distances et accessibilité

## Méthodologie

Les distances et les temps de trajet pour la métropole d'Aix-Marseille ont été calculées en utilisant :

-   Les **données MOBPRO** pour sélectionner les paires de communes. Cela évite de calculer des distances entre des origines destinations sans lien. L'inconvénient est qu'on ne produit pas les distances pour des communes non reliées et donc on ne comprend pas l'absence de lien.

-   Pour les **transports en commun**, les GTFS répertoriés sur [Open Data - lepilote](https://www.lepilote.com/fr/open-data/83), le moteur employé est R^5^ e Conveyal. On a retenu soit la médiane, soit le quantile 5% sur une plage horaire d'une heure (de 8h à 9h, le matin, un jour de semaine hors période de congé). Ceci permet de tenir compte des fréquences et des temps de correspondance. Le quantile 5% représente la possibilité de choisir son horaire pour optimiser son temps de trajet.

-   Pour la **voiture,** les données OSM (téléchargées en décembre 2023) et le moteur de routage `dodgr` qui a été optimisé pour un calcul bien plus rapide. En plus des distances et des temps de trajet, on calcule les dénivelés et on pourra en tenir compte pour les émissions ultérieurement. Les vitesses de déplacement sont les limitations de vitesse en vigueur (ou renseignées sur OSM), modulées en fonction des types de route. Une pénalité pour les feux rouges ainsi que pour les changements de direction (traversée d'un carrefour) est appliquée. A ce stade, faute de données convaincantes, la **congestion** n'est pas intégrée. En utilisant la couche de mapbox sur le trafic habituel, il est envisageable de calculer les temps de parcours avec la congestion habituelle moyennant quelques hypothèses).

-   Pour le **vélo** et la **marche**, le moteur de calcul et les données sont les mêmes que pour la voiture, en utilisant bien sûr des vitesses conformes. Un coût du dénivelé positif est introduit pour ces deux modes, réduisant la vitesse lors des montées et l'augmentant pour le vélo uniquement pour les pentes inférieures à 5%. Aucun élément de stress à vélo n'est pris en compte, cela pourra être fait ultérieurement.

## Accessibilité par mode de transport

L'accessibilité consiste à mesure pour chque lieu de résidence le temps d'accès à un seuil d'emploi (par exemple 100 000 emplois). Cette notion n'est pas directement reliée aux distances parcourues, puisque *in fine* chqeu individu n'occupe qu'un emploi. L'accessibilité permet en revanche de mesurer le potentiel d'emploi qui s'offre à partir d'un lieu de résidence.

On relie facilement et nettement l'accessibilité à la valeur du foncier.

L'accessibilité permet également de comparer l'efficacité relative des modes de transports et illustre la domination de la voiture sur la plupart des lieux du territoire.

L'accessibilité permet également de caractériser le territoire et de commencer à approcher les questions de distribution spatiale.

Les cartes suivantes présentent l'accessibilité à 50 000 emplois pour 4 modes de transport.

Pour les déplacements à pied ou en vélo, une fonction de coût à la Tobler a été introduite. Cette fonction de coût pénalise par des vitesses de déplacement moindre les dénivelés positifs. Les accessibilités sans ces fonctions sont téléchargeables en dessous des cartes.

::: {.panel-tabset .column-screen}

## voiture


```{r}
#| label: fig-access-car
#| fig-cap: Accessibilité à 50 000 emplois en voiture
communes <- bd_read("communes")
centre <- communes |> 
  filter(INSEE_COM==13015) |> 
  st_transform(4326) |> 
  st_centroid() |> 
  st_coordinates()
centre <- as.vector(centre)
t_access <- bd_read("t_access")
t_access |> 
  filter(mode == "car_dgr2") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    ind,
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to50k = trim(to50k, 0, 60)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to50k", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```


## transit


```{r}
#| label: fig-access-transit
#| fig-cap: Accessibilité à 50 000 emplois en transit (q5%)
t_access |> 
  filter(mode == "transit5") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    ind,
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to50k = trim(to50k, 0, 60)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to50k", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```


## vélo


```{r}
#| label: fig-access-bike
#| fig-cap: Accessibilité à 50 000 emplois en vélo
t_access |> 
  filter(mode == "bike_tblr") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    ind, 
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to50k = trim(to50k, 0, 60)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to50k", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```


## marche à pied


```{r}
#| label: fig-access-walk
#| fig-cap: Accessibilité à 50 000 emplois en vélo
t_access |> 
  filter(mode == "walk_tblr") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    ind, 
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to50k = trim(to50k, 0, 60)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to50k", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```

:::


```{r}
download_this(
  t_access |> 
    st_drop_geometry(),
  button_label = "données temps d'accessibilité au carreau",
  output_name = "temsp_accessibilite_idINS_MetAM"
)
```


## Accessibilité par commune

On reconstruit la relation entre le nombre d'emploi accessible (axe des y)  et le temps de déplacement pour chaque mode pour chaque commune. Cette relation est basée sur une moyenne pondérée par le nombre d'actifs sur chacun des carreaux de l'emploi accessible pour un temps donné.




```{r}
# fig-label: fig-acces-com
# fig-caption: Accessibilité à l'emploi par communes
access_par_com <- bd_read("access_par_com")

ggplot(
  access_par_com |> 
    filter(mode %in% c("car_dgr2", "transit5", "bike_tblr", "walk_tblr"))) +
  geom_line(aes(x=temps, y=emp, group=com22), col="gray80", linewidth=0.2) +
  geom_line(data = ~filter(.x, !str_detect(label, "^n")),
            aes(x=temps, y=emp, color=label)) +
  scale_x_continuous(breaks  = c(0, 20,40,60,80,100,120), limits = c(0,60))+
  scale_y_continuous(labels = ofce::f2si2)+
  ofce::theme_ofce(base_size = 8)+
  xlab("temps en minutes") +
  ylab("emploi maximum") +
  labs(color="Communes")+
  theme(legend.position = c(0.01, 0.99),
        legend.justification = c(0,1),
        legend.key.size = unit(6, "pt"),
        panel.spacing = unit(12, "pt"),
        plot.margin = margin(l = 6, r= 6),
        panel.grid.major.x = element_line(color="gray80", linewidth = 0.1))+
  facet_wrap(vars(mode))

```


Les arrondissements de Marseille (dont le 3e et le 7e sont colorés) sont les seuls à disposer d'une accessibilité assez élevée en transit. On constate également la domination de la voiture sur l'ensemble du territoire.

Il est à noter que la restriction aux paires de communes issues de MOBPRO empêche certains territoires de pouvoir accéder à des niveaux d'emplois élevé (comme Fos-sur Mer).

## Distribution de l'accessibilité

::: {.panel-tabset .column-screen}


```{r}
t_access  <- t_access |> 
  mutate(zone = case_match(
    com22,
    str_c(13201:13216) ~ "Marseille",
    "13039"  ~ 'Fos-sur-Mer',
    "13001" ~ 'Aix-en-Provence', 
    .default = "autres"))
```

## 10k


```{r}
ggplot(t_access |> filter(mode!="transit"))+
  geom_density(aes(x=to10k, weight=ind , fill = zone, col= zone, y = after_stat(count) ), alpha=.5, position="stack") + 
  scale_color_manual(
    aesthetics = c("color", "fill"), 
    values = c("Marseille" = "chartreuse2", "Aix-en-Provence"="darkorchid1", "Fos-sur-Mer"="blue3", "autres" = "grey") ) +
  facet_wrap(vars(mode)) +
  ylim(c(0, 3000))+
  theme_ofce(base_size = 9)
```


## 20k



```{r}
ggplot(t_access |> filter(mode!="transit"))+
  geom_density(aes(x=to20k, weight=ind , fill = zone, col= zone, y = after_stat(count) ), alpha=.5, position="stack") + 
  scale_color_manual(
    aesthetics = c("color", "fill"), 
    values = c("Marseille" = "chartreuse2", "Aix-en-Provence"="darkorchid1", "Fos-sur-Mer"="blue3", "autres" = "grey") ) +
  facet_wrap(vars(mode)) +
  ylim(c(0, 3000))+
  theme_ofce(base_size = 9)
```


## 50k


```{r}
ggplot(t_access |> filter(mode!="transit"))+
  geom_density(aes(x=to50k, weight=ind , fill = zone, col= zone, y = after_stat(count) ), alpha=.5, position="stack") + 
  scale_color_manual(
    aesthetics = c("color", "fill"), 
    values = c("Marseille" = "chartreuse2", "Aix-en-Provence"="darkorchid1", "Fos-sur-Mer"="blue3", "autres" = "grey") ) +
  facet_wrap(vars(mode)) +
  ylim(c(0, 3000))+
  theme_ofce(base_size = 9)
```


## 100k


```{r}
ggplot(t_access |> filter(mode!="transit"))+
  geom_density(aes(x=to100k, weight=ind , fill = zone, col= zone, y = after_stat(count) ), alpha=.5, position="stack") + 
  scale_color_manual(
    aesthetics = c("color", "fill"), 
    values = c("Marseille" = "chartreuse2", "Aix-en-Provence"="darkorchid1", "Fos-sur-Mer"="blue3", "autres" = "grey") ) +
  facet_wrap(vars(mode)) +
  ylim(c(0, 3000))+
  theme_ofce(base_size = 9)
```


## 200k


```{r}
ggplot(t_access |> filter(mode!="transit"))+
  geom_density(aes(x=to200k, weight=ind , fill = zone, col= zone, y = after_stat(count) ), alpha=.5, position="stack") + 
  scale_color_manual(
    aesthetics = c("color", "fill"), 
    values = c("Marseille" = "chartreuse2", "Aix-en-Provence"="darkorchid1", "Fos-sur-Mer"="blue3", "autres" = "grey") ) +
  facet_wrap(vars(mode)) +
  ylim(c(0, 3000))+
  theme_ofce(base_size = 9)
```

:::
