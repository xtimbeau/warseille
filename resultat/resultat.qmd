---
title: "Métropole d'Aix-Marseille"
subtitle: Premiers résultats
author:
  - name: Xavier Timbeau
  - name: Jeanne Devineau
  - name: Maxime Parodi
institution: "OFCE"
date: today
date-modified: today
lang: fr
wp: tbc
annee: 2023
draft: true
format:
  ofce-html: default
bibliography: resultat_references.bib
editor: visual
execute: 
  echo: false
  warning: false
---

```{r, include=FALSE}
library(knitr)
library(sf)
library(tidyverse)
library(showtext)
library(mapdeck)
library(ofce)
library(downloadthis)
opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.pos="H", 
  out.extra="",
  dev="ragg_png",
  fig.showtext=TRUE,
  cache=FALSE)
source("../secrets/azure.R")
showtext_opts(dpi=200)
showtext_auto()
trim <- function(x, xm, xp) ifelse( x<= xm, xm, ifelse(x>= xp, xp, x))

communes <- bd_read("communes")
centre <- communes |> 
  filter(INSEE_COM=="13019") |> 
  st_transform(4326) |> 
  st_centroid() |> 
  st_coordinates()
centre <- as.vector(centre)

c200ze <- bd_read("c200ze") |> st_transform(4326)

```

## Localisation des résidents, des actifs et des emplois

On limite l'analyse à la métropole d'Aix-Marseille-Provence. Cela représente 26 000 carreaux 200m x 200m pour 107 communes/arrondissements Les opportunités sont les emplois, 95% des emplois occupés par les actifs de la métropole sont couverts. On a retenu 21 143 carreaux d'opportunité pour un peu moins de 680k emplois.

L'analyse est basée sur les données du recensement (MOBPRO). La définition de l'emploi est donc celle de l'emploi au sens large (salairés, non salariés, fonctionnaires) et peut différer des sources entreprises (DSN, FLORES). L'avantage est la cohérence entre les actifs et les emplois. L'année de référence est la [dernière disponible, 2020](https://www.insee.fr/fr/statistiques/7637844?sommaire=7637890&q=mobilite+professionnelle).

La source MOBPRO nous permet de disinguer l'emploi de l'emploi "résident", ce dernier étant l'emploi occupé par des résidents du périmètre retenu (EPCI Métropole d'Aix-Marseille Provence).

Pour la localisation des résidents, on exploite les [données carroyées de l'INSEE (pour l'année 2017)](https://www.insee.fr/fr/statistiques/6215138?sommaire=6215217) sur lesquelles on applique les données MOPBRO, donc l'année 2020. Les données carroyées définissent donc la répartition spatiale infra communale alors que les données de résident sont calées au niveau communal/arrondissement sur MOBPRO.

Pour la localisation des emplois, on utilise les [fichiers fonciers (CEREMA) pour l'année 202](https://datafoncier.cerema.fr/fichiers-fonciers)2 ainsi que le [Référentiel présumé Public Foncier (2022)](https://datafoncier.cerema.fr/referentiel-foncier-presume-public) pour la répartition spatiale infra-communal. L'emploi est calé sur le niveau communal par MOBPRO (année 2020) en cohérence avec les résidents et les actifs. Pour la répartition spatiale, on utilise un modèle log-log reliant l'emploi au surface pour une division de l'emploi et des surfaces en 5 secteurs (AZ agriculture, BE industrie, FZ construction, GU services, OQ secteur public), telle que définie dans MOBPRO. Cete approche permet de tenir compte de certaines très grandes surfaces (comme le port de Marseille, l'Aeroport) pour lesquelles la densité d'emploi n'est pas la même aque de plus petites surfaces. Néanmoins, la très grande surface du port de Marseille (classé en OQ) conduit à imputer beaucoup de l'emploi public du 2eme arrondissement de Marseille à ce lieu. Une analyse plus fine (grand établissement par grand établissement) est possible mais très coûteuse pour un gain probablement marginal en précision. Pour l'agriculture, les surfaces professionnelles ne sont pas bien identifiées (en tout cas par notre méthode). On utilise donc une répartition suivant les individus pour les communes agricoles. Les emplois concernés sont très faibles (voir @fig-surf2emp).

```{r}
#| label: fig-surf2emp
#| fig-cap: modélisation du lien entre emploi et surface

bd_read("gsurf2emp")  
```

::: {.panel-tabset .column-screen}

## résidents c200 (2017)

```{r}
#| label: fig-resident
#| fig-cap: localisation des résidents

c200ze |> 
  mutate(
    act = tactocc1564 * ind_18_64) |> 
  filter(ind > 0, scot) |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {round(act_mobpro)} actifs dans le carreau<br>
     {POPULATION} dans la commune"),
    ind = trim(ind/4, 0, 500)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "ind", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "oranges",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "pers./ha"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)


```

```{r}
download_this(
  c200ze |> 
    st_drop_geometry() |> 
  filter(ind > 0, scot) |> 
  transmute(
    idINS, ind, dep, idcom=com22, IRIS,
    act = tactocc1564 * ind_18_64),
  button_label  = "données ind&actifs au carreau",
  output_name = "ind_act_idINS_MetAM"
)
```

## actifs MOBPRO (2020)

```{r}
#| label: fig-actif
#| fig-cap: localisation des actifs (MOBPRO, 2020)
c200ze |> 
  mutate(
    act = tactocc1564 * ind_18_64) |> 
  filter(ind > 0, scot) |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {round(act_mobpro)} actifs dans le carreau<br>
     {POPULATION} dans la commune"),
    act_mobpro = trim(act_mobpro/4, 0, 500)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "act_mobpro", 
              elevation = "act_mobpro", 
              elevation_scale = 3, 
              palette= "blues",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "pers./ha"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)


```

```{r}
download_this(
  c200ze |> 
    st_drop_geometry() |> 
  filter(ind > 0, scot) |> 
  transmute(
    idINS, ind, dep, idcom=com22, IRIS,
    act = tactocc1564 * ind_18_64),
  button_label  = "données ind&actifs au carreau",
  output_name = "ind_act_idINS_MetAM"
)
```

## emploi MOBPRO (2020)

```{r}
#| label: fig-emplois
#| fig-cap: Localisation des emplois occupés par des actifs de la métropole
c200ze |> 
  filter(emp > 0) |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {round(emp)} emplois occupés dans le carreau<br>
     {POPULATION} dans la commune"),
    emp_resident = trim(emp_resident/4, 0, 500)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "emp_resident", 
              elevation = "emp_resident", 
              elevation_scale = 3, 
              palette= "purples",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "emp./ha"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)

```

```{r}
download_this(
  c200ze |> 
    st_drop_geometry() |> 
  filter(emp > 0) |> 
  transmute(
    idINS, emp, emp_resident, idcom=com22, IRIS,
    act = tactocc1564 * ind_18_64),
  button_label  = "données emploi&emploi résident au carreau",
  output_name = "emp_empres_idINS_MetAM"
)
```
:::

## Calcul des distances {#sec-introduction .unnumbered}

Les distances et les temps de trajet pour la métropole d'Aix-Marseille ont été calculées en utilisant :

-   Les **données MOBPRO** pour sélectionner les paires de communes. Cela évite de calculer des distances entre des origines destinations sans lien. L'inconvénient est qu'on ne produit pas les distances pour des communes non reliées et donc on ne comprend pas l'absence de lien.

-   Pour les **transports en commun**, les GTFS répertoriés sur [Open Data - lepilote](https://www.lepilote.com/fr/open-data/83), le moteur employé est R^5^ e Conveyal. On a retenu soit la médiane, soit le quantile 5% sur une plage horaire d'une heure (de 8h à 9h, le matin, un jour de semaine hors période de congé). Ceci permet de tenir compte des fréquences et des temps de correspondance. Le quantile 5% représente la possibilité de choisir son horaire pour optimiser son temps de trajet.

-   Pour la **voiture,** les données OSM (téléchargées en décembre 2023) et le moteur de routage `dodgr` qui a été optimisé pour un calcul bien plus rapide. En plus des distances et des temps de trajet, on calcule les dénivelés et on pourra en tenir compte pour les émissions ultérieurement. Les vitesses de déplacement sont les limitations de vitesse en vigueur (ou renseignées sur OSM), modulées en fonction des types de route. Une pénalité pour les feux rouges ainsi que pour les changements de direction (traversée d'un carrefour) est appliquée. A ce stade, faute de données convaincantes, la **congestion** n'est pas intégrée. En utilisant la couche de mapbox sur le trafic habituel, il est envisageable de calculer les temps de parcours avec la congestion habituelle moyennant quelques hypothèses).

-   Pour le **vélo** et la **marche**, le moteur de calcul et les données sont les mêmes que pour la voiture, en utilisant bien sûr des vitesses conformes. Un coût du dénivelé positif est introduit pour ces deux modes, réduisant la vitesse lors des montées et l'augmentant pour le vélo uniquement pour les pentes inférieures à 5%. Aucun élément de stress à vélo n'est pris en compte, cela pourra être fait ultérieurement.

## Accessibilité par mode de transport

L'accessibilité consiste à mesure pour chque lieu de résidence le temps d'accès à un seuil d'emploi (par exemple 100 000 emplois). Cette notion n'est pas directement reliée aux distances parcourues, puisque *in fine* chqeu individu n'occupe qu'un emploi. L'accessibilité permet en revanche de mesurer le potentiel d'emploi qui s'offre à partir d'un lieu de résidence.

On relie facilement et nettement l'accessibilité à la valeur du foncier.

L'accessibilité permet également de comparer l'efficacité relative des modes de transports et illustre la domination de la voiture sur la plupart des lieux du territoire.

L'accessibilité permet également de caractériser le territoire et de commencer à approcher les questions de distribution spatiale.

Les cartes suivantes présentent l'accessibilité à 100 000 emplois pour 4 modes de transport.

Pour les déplacements à pied ou en vélo, une fonction de coût à la Tobler a été introduite. Cette fonction de coût pénalise par des vitesses de déplacement moindre les dénivelés positifs. Les acccessibilités sans ces fonctions sont téléchargeables en dessous des cartes.

::: {.panel-tabset .column-screen}
## voiture

```{r}
#| label: fig-access-car
#| fig-cap: Accessibilité à 100 000 emplois en voiture
communes <- bd_read("communes")
centre <- communes |> 
  filter(INSEE_COM==13015) |> 
  st_transform(4326) |> 
  st_centroid() |> 
  st_coordinates()
centre <- as.vector(centre)
t_access <- bd_read("t_access")
t_access |> 
  filter(mode == "car_dgr2") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  mutate(tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to100k = trim(to100k, 0,45)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to100k", 
              elevation = "ind", 
              elevation_scale = .3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```

## transit

```{r}
#| label: fig-access-transit
#| fig-cap: Accessibilité à 100 000 emplois en transit (q5%)
t_access |> 
  filter(mode == "transit5") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  mutate(tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to100k = trim(to100k, 0,45)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to100k", 
              elevation = "ind", 
              elevation_scale = .3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```

## vélo

```{r}
#| label: fig-access-bike
#| fig-cap: Accessibilité à 100 000 emplois en vélo
t_access |> 
  filter(mode == "bike_tblr") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  mutate(tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to100k = trim(to100k, 0,45)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "66vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to100k", 
              elevation = "ind", 
              elevation_scale = .3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```

## marche

```{r}
#| label: fig-access-walk
#| fig-cap: Accessibilité à 100 000 emplois en vélo
t_access |> 
  filter(mode == "walk_tblr") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  mutate(tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to100k = trim(to100k, 0,45)) |> 
  st_transform(4326) |> 
  mapdeck(style = 'mapbox://styles/xtimbeau/ckg2d9ypq0lzv19m8p6a7xqoi',
          height = "66vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to100k", 
              elevation = "ind", 
              elevation_scale = .3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```
:::

```{r}
download_this(
  t_access |> 
    st_drop_geometry(),
  button_label  = "données temps d'accessibilité au carreau",
  output_name = "temsp_accessibilite_idINS_MetAM"
)
```
