```{r init, include=FALSE}
source("init.R")
```

# Calcul des distances et accessibilité

L'accessibilité découle du calcul des distances par mode et des localisations des opportunités (ici les emplois) sur le territoire. Elle mesure le potentiel de mobilité en chaque point, qui ne doit pas être confondu avec la pratique de mobilité qui sera évaluée ensuite.

L'accessibilité est définie comme le nombre d'opportunités – des emplois – que l'on peut atteindre en un temps donné en partant d'un lieu donné. On utilise également le terme accessibilité pour désigner le temps qu'il faut pour atteindre un nombre d'emplois donné. Les deux notions sont réciproquement liées.

Le calcul de l'accessibilité suppose le calcul de toutes les distances entre les paires de lieux de résidence - lieux d'emploi. Pour la métropole d'Aix-Marseille, la volumétrie est importante ( $26k \times 21k \times4= 2,1G$ paires de distances calculées. En plus des distances, on calcule systématiquement les temps de parcours et les dénivelés positifs le long du parcours.

Parce que l'accessibilité mesure un potentiel, elle est un facteur puissant pour expliquer les prix de l'immobilier, du moins en général. La forme urbaine particulière, la forte ségrégation et la valorisation d'aménités comme la proximité de la mer, d'espaces naturels ou simplement la "vue" peuvent contredire l'analyse univariée par l'accessibilité seule.

Malgré ces réserves, l'accessibilité permet une cartographie originale du territoire.

## Méthodologie

Les distances et les temps de trajet pour la métropole d'Aix-Marseille ont été calculées en utilisant :

-   Les **données MOBPRO** pour sélectionner les paires de communes. Cela évite de calculer des distances entre des origines destinations sans lien. L'inconvénient est qu'on ne produit pas les distances pour des communes non reliées et donc on ne comprend pas l'absence de lien. La notion d'emploi est celle déclarée pour le recensement, qui peut différer de sources "entreprises". C'est une notion couvrant toutes les formes contractuelles (salariés, non salariés, emploi public).

-   Pour les **transports en commun**, les GTFS répertoriés sur [Open Data - lepilote](https://www.lepilote.com/fr/open-data/83), le moteur employé est R^5^ e Conveyal. On a retenu soit la médiane, soit le quantile 5% sur une plage horaire d'une heure (de 8h à 9h, le matin, un jour de semaine hors période de congé, en l’occurrence le 14/06/2022). Ceci permet de tenir compte des fréquences et des temps de correspondance (en fonction des horaires diffusés pour ce jour là). Le quantile 5% représente la possibilité de choisir son horaire de départ entre 8h et 9h pour minimiser son temps de trajet.

-   Pour la **voiture,** les données OSM (téléchargées en décembre 2023) et le moteur de routage `dodgr` qui a été optimisé pour un calcul bien plus rapide. En plus des distances et des temps de trajet, on calcule les dénivelés et on pourra en tenir compte pour les émissions ultérieurement. Les vitesses de déplacement sont les limitations de vitesse en vigueur (ou renseignées sur OSM), modulées en fonction des types de route. Une pénalité pour les feux rouges ainsi que pour les changements de direction (traversée d'un carrefour) est appliquée. A ce stade, faute de données convaincantes, la **congestion** n'est pas intégrée. En utilisant la couche de mapbox sur le trafic habituel, il est envisageable de calculer les temps de parcours avec la congestion habituelle moyennant quelques hypothèses).

-   Pour le **vélo** et la **marche**, le moteur de calcul et les données sont les mêmes que pour la voiture, en utilisant bien sûr des vitesses conformes. Un coût du dénivelé positif est introduit pour ces deux modes, réduisant la vitesse lors des montées et l'augmentant pour le vélo uniquement pour les pentes inférieures à 5%. Aucun élément de "stress" à vélo n'est pris en compte, cela pourra être fait ultérieurement.

## Accessibilité par mode de transport

L'accessibilité consiste à mesure pour chaque lieu de résidence le temps d'accès à un seuil d'emploi (par exemple 100 000 emplois). Cette notion n'est pas directement reliée aux distances parcourues, puisque *in fine* chaque individu n'occupe qu'un emploi et que les comportements de choix, de mode de transport conditionneront la pratique. L'accessibilité permet en revanche de mesurer le potentiel d'emploi qui s'offre à partir d'un lieu de résidence. On relie ainsi nettement l'accessibilité à la valeur du foncier.

L'accessibilité permet également de comparer l'efficacité relative des modes de transports et illustre la domination de la voiture sur la plupart des lieux du territoire. L'accessibilité permet également de caractériser le territoire et de commencer à approcher les questions de distribution spatiale.

Les cartes suivantes présentent l'accessibilité à 50 000 emplois pour 4 modes de transport. La dimension "*z*" (ou la hauteur des colonnes) représente la population du carreau.

Pour les déplacements à pied ou en vélo, une fonction de coût à la Tobler a été introduite. Cette fonction de coût pénalise par des vitesses de déplacement moindres les dénivelés positifs. Les accessibilités calculées sans ces fonctions de coût sont téléchargeables en dessous des cartes, en même temps que les données utilisées pour les cartes.

::: {.panel-tabset .column-screen}
## voiture

```{r}
#| label: fig-access-car
#| fig-cap: Accessibilité à 50k emplois en voiture
communes <- bd_read("communes")
t_access <- bd_read("t_access")
t_access |> 
  filter(mode == "car_dgr2") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    ind=ind/4,
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to50k = trim(to50k, 0, 60)) |> 
  st_transform(4326) |> 
  mapdeck(style = style,
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to50k", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "blues",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```

## transit

```{r}
#| label: fig-access-transit
#| fig-cap: Accessibilité à 50k emplois en transit (q5%)
t_access |> 
  filter(mode == "transit5") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    ind=ind/4,
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to50k = trim(to50k, 0, 60)) |> 
  st_transform(4326) |> 
  mapdeck(style = style,
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to50k", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```

## vélo

```{r}
#| label: fig-access-bike
#| fig-cap: Accessibilité à 50k emplois en vélo
t_access |> 
  filter(mode == "bike_tblr") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    ind=ind/4, 
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to50k = trim(to50k, 0, 60)) |> 
  st_transform(4326) |> 
  mapdeck(style = style,
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to50k", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```

## marche à pied

```{r}
#| label: fig-access-walk
#| fig-cap: Accessibilité à 50k emplois en vélo
t_access |> 
  filter(mode == "walk_tblr") |> 
  left_join(communes |>
              st_drop_geometry() |>
              select(com22=INSEE_COM, NOM, POPULATION)) |> 
  transmute(
    ind=ind/4, 
    tooltip=glue::glue(
    "{NOM} {com22}<br>
     {ind} ind dans le carreau<br>
     {POPULATION} dans la commune<br>
     accès à 20k: {round(to20k)} min<br>
     accès à 50k: {round(to50k)} min<br>
     accès à 100k: {round(to100k)} min<br>"),
    to50k = trim(to50k, 0, 60)) |> 
  st_transform(4326) |> 
  mapdeck(style = style,
          height = "50vh",
          width = "100%") |> 
  add_polygon(fill_colour = "to50k", 
              elevation = "ind", 
              elevation_scale = 3, 
              palette= "rainbow",
              legend = TRUE, 
              tooltip = "tooltip",
              legend_options = list(title = "minutes"),
              legend_format = list(fill_colour = as.integer)) |> 
  mapdeck_view(location = centre, zoom = 9, pitch = 0, bearing = 0)
```
:::

```{r}
download_this(
  t_access |> 
    st_drop_geometry(),
  icon = "fa fa-download",
  class = "dnwld_button",
  button_label = "données temps d'accessibilité au carreau",
  output_name = "temsp_accessibilite_idINS_MetAM"
)
```

## Accessibilité par commune

On reconstruit la relation entre le nombre d'emploi accessible (axe des *y*) et le temps de déplacement pour chaque mode et pour chaque commune. Cette relation est basée sur une moyenne pondérée par le nombre d'actifs sur chacun des carreaux de l'emploi accessible en un temps donné.

```{r}
# fig-label: fig-acces-com
# fig-caption: Accessibilité à l'emploi par communes
access_par_com <- bd_read("access_par_com")
colors <- c("Marseille 3e" = "chartreuse",
            "Marseille 7e" = "chartreuse3", 
            "Aix-en-Provence"="deeppink", 
            "Fos-sur-Mer"="deepskyblue",
            "Tout le territoire" = "orange")

ggplot(
  access_par_com |> 
    filter(mode %in% c("car_dgr2", "transit5", "bike_tblr", "walk_tblr"))) +
  geom_line(aes(x=temps, y=emp, group=com22), col="gray80", linewidth=0.2) +
  geom_line(data = ~filter(.x, !str_detect(label, "^n")),
            aes(x=temps, y=emp, color=label)) +
  scale_color_manual(values = colors)+
  scale_x_continuous(breaks  = c(0, 20,40,60,80,100,120), limits = c(0,60))+
  scale_y_continuous(labels = ofce::f2si2)+
  ofce::theme_ofce(base_size = 8)+
  xlab("temps en minutes") +
  ylab("emploi maximum") +
  labs(color="Communes")+
  theme(legend.position = c(0.01, 0.99),
        legend.justification = c(0,1),
        legend.key.size = unit(8, "pt"),
        panel.spacing = unit(12, "pt"),
        plot.margin = margin(l = 6, r= 6),
        panel.grid.major.x = element_line(color="gray80", linewidth = 0.1))+
  facet_wrap(vars(mode))

```

```{r}
download_this(
access_par_com,
  class  = "dnwld_button",
  icon = "fa fa-download",
  button_label  = "données temps d'accès par commune",
  output_name = "access_commune_metAM"
)
```

Les arrondissements de Marseille (dont le 3e et le 7e sont colorés) sont les seuls à disposer d'une accessibilité assez élevée en transit. On constate également la domination de la voiture sur l'ensemble du territoire.

Il est à noter que la restriction aux paires de communes issues de MOBPRO empêche certains territoires de pouvoir accéder à des niveaux d'emplois élevé (comme Fos-sur Mer).

## Population et accessibilité

On regarde ici le nombre d'individus selon leur temps d'accès à différents seuils d'emploi (auxquels on accède par les onglets). Plus le seuil est important, plus les individus sont décalés vers la droite. L'axe des x est limité et donc des individus (dont le temps d'accès au seuil d'emploi est supérieur à 120 minutes) disparaissent du graphique.

Les courbes représentent la densité de population en fonction du temps d'accessibilité. Les colorations identifient certains territoires suivant la même règle que pour le graphique d'accessibilité par commune. L'échelle des y est limitée à 1500 pour la lisibilité. L'aire des courbes est proportionnelle à la population (moins les individus dont les temps d'accès sont supérieurs à 120 minutes).

::: panel-tabset
```{r}
t_access  <- t_access |> 
  mutate(zone = case_match(
    com22,
    str_c(13201:13216) ~ "Marseille",
    "13039"  ~ 'Fos-sur-Mer',
    "13001" ~ 'Aix-en-Provence', 
    .default = "autres"))

colors <- c("Marseille" = "chartreuse2", "Aix-en-Provence"="deeppink", "Fos-sur-Mer"="deepskyblue", "autres" = "darkgoldenrod2")

gg_cmd <- list(
  geom_density(alpha=.5, position="stack", bw = 5, linewidth = 0.2), 
  facet_wrap(vars(mode)),
  scale_color_manual(
    aesthetics = c("color", "fill"), 
    values = colors ),
  scale_y_continuous(oob=scales::squish, limits = c(0,1500), name = "population"),
  scale_x_continuous(breaks = c(0:6)*20, limits=c(0,120)),
  theme_ofce(base_size = 9),
  labs(caption = "Source : INSEE, Fichiers fonciers ; Calcul : OFCE"),
  guides(
    color = guide_legend(keywidth = 1, keyheight = .5),
    alpha="none"),
  theme(legend.text = element_text(margin=margin(t=2, unit="pt"))))
```

## 10k

```{r}
#| label: fig-dist10k
#| fig-cap: Distribution selon le temps d'accès à 10k emplois

ggplot(t_access |> filter(mode!="transit"))+
  aes(x=to10k, weight=ind , fill = zone, col= zone, y = after_stat(count))+
  gg_cmd
```

## 20k

```{r}
#| label: fig-dist20k
#| fig-cap: Distribution selon le temps d'accès à 20k emplois

ggplot(t_access |> filter(mode!="transit"))+
  aes(x=to20k, weight=ind , fill = zone, col= zone, y = after_stat(count) )+
  gg_cmd
```

## 50k

```{r}
#| label: fig-dist50k
#| fig-cap: Distribution selon le temps d'accès à 50k emplois

ggplot(t_access |> filter(mode!="transit"))+
  aes(x=to50k, weight=ind , fill = zone, col= zone, y = after_stat(count))+
        gg_cmd
```

## 100k

```{r}
#| label: fig-dist100k
#| fig-cap: Distribution selon le temps d'accès à 100k emplois

ggplot(t_access |> filter(mode!="transit"))+
  aes(x=to100k, weight=ind , fill = zone, col= zone, y = after_stat(count))+
  gg_cmd
```

## 200k

```{r}
#| label: fig-dist200k
#| fig-cap: Distribution selon le temps d'accès à 200k emplois

ggplot(t_access |> filter(mode!="transit"))+
  aes(x=to200k, weight=ind , fill = zone, col= zone, y = after_stat(count))+
  gg_cmd
```
:::

## Accessibilité et revenu

On utilise le revenu moyen par unité de consommation au carreau (et donc une donnée de 2017) pour représenter le lien entre niveau de vie et accessibilité.

{{< fa exclamation-triangle >}} Attention, ce niveau de vie est appliqué de façon homogène à tous les habitants du carreau, ce qui conduit à une "moyennisation" de la donnée. On pourra avec Fidéli améliorer ce point et disposer de données plus récentes (2021).

```{r}
library(MetricsWeighted)
library(santoku)

c200ze <- c200ze |> 
  mutate(
    ndv = ind_snv/ind,
    decile = chop(
      ndv,
      weighted_quantile(ndv, w = ind, probs = 1:10/10, names=FALSE),
      labels = str_c("d", 1:10)))
  
d_access <- t_access |>
  st_drop_geometry() |>
  left_join(
    c200ze |> st_drop_geometry() |> select(idINS200 = idINS, ndv, decile),
    by = "idINS200") |> 
  filter(mode %in% c("bike_tblr", "car_dgr2", "transit5", "walk_tblr")) |> 
  mutate(
    zone = case_match(com22,
                      str_c(13201:13216) ~ "Marseille",
                      "13039"  ~ 'Fos-sur-Mer',
                      "13001" ~ 'Aix-en-Provence', 
                      .default = "autres"))

deciles <- c200ze |> 
  st_drop_geometry() |> 
  mutate(
    zone = case_match(com22,
                      str_c(13201:13216) ~ "Marseille",
                      "13039"  ~ 'Fos-sur-Mer',
                      "13001" ~ 'Aix-en-Provence', 
                      .default = "autres")) |> 
  group_by(zone, decile) |> 
  summarize(ind = sum(ind), .groups = "drop")

gg_cmd <- list(
  theme_ofce(),
  geom_boxplot(outlier.shape = NA, alpha=0.5, varwidth=FALSE, 
               linewidth= 0.2),
  facet_wrap(vars(mode)),
  ylim(c(0,60)),
  scale_color_manual(
    name=NULL,
    aesthetics = c("color", "fill"), 
    values = colors ),
  theme(legend.position = "bottom"),
  labs(caption = "Source : INSEE, Fichiers fonciers ; Calcul : OFCE"),
  guides(
    color = guide_legend(keywidth = 1, keyheight = .5)))

colors <- c("Marseille" = "chartreuse2", "Aix-en-Provence"="deeppink", "Fos-sur-Mer"="deepskyblue", "autres" = "darkgoldenrod2")


```

{{< fa exclamation-triangle >}} La répartition des déciles dans les zones sélectionnées est loin d'être homogène. Le graphique @fig-repartition matérialise cette remarque. Par construction, chaque décile de revenu comporte le même nombre d'individus,

```{r}
#| label: fig-repartition
#| fig-cap: Répartition de la population par décile par zone

ggplot(deciles)+
  geom_bar(aes(x=decile, fill=zone, weight = ind), 
           col="white", width = 0.5)+
  scale_y_continuous(labels = ofce::f2si2, name="population")+
  scale_fill_manual(name=NULL, values = colors)+
  theme_ofce()+
  xlab(NULL)+
  labs(caption = "Source : données carroyées INSEE 2017 ; Calcul : OFCE") +
  theme(legend.position = "bottom",
        legend.key.size = unit(8, "pt")) 

```

```{r}
download_this(
  deciles,
  class  = "dnwld_button",
  icon = "fa fa-download",
  button_label  = "données répartition des deciles",
  output_name = "deciles_metAM"
)
```

Pour chaque décile de niveau de vie, on représente la distribution des temps d'accès au seuil indiqué.

::: panel-tabset
## 10k

```{r}
#| label: fig-dec10k
#| fig-cap: Distribution selon le revenu des accès à 10k emplois

ggplot(d_access) +
  aes(x = decile, y = to10k, weight= ind,  col = zone) +
  gg_cmd 
```

## 20k

```{r}
#| label: fig-dec20k
#| fig-cap: Distribution selon le revenu des accès à 20k emplois

ggplot(d_access) +
  aes(x = decile, y = to20k, weight= ind,  col = zone) +
  gg_cmd
```

## 50k

```{r}
#| label: fig-dec50k
#| fig-cap: Distribution selon le revenu des accès à 50k emplois

ggplot(d_access) +
  aes(x = decile, y = to50k, weight= ind,  col = zone) +
  gg_cmd
```

## 100k

```{r}
#| label: fig-dec100k
#| fig-cap: Distribution selon le revenu des accès à 100k emplois

ggplot(d_access) +
  aes(x = decile, y = to100k, weight= ind,  col = zone) +
  gg_cmd
```

## 200k

```{r}
#| label: fig-dec200k
#| fig-cap: Distribution selon le revenu des accès à 200k emplois

ggplot(d_access) +
  aes(x = decile, y = to200k, weight= ind,  col = zone) +
  gg_cmd
```
:::

```{r}
download_this(
d_access,
  class  = "dnwld_button",
  icon = "fa fa-download",
  button_label  = "données accessibilité et revenu au carreau",
  output_name = "access_revenu_metAM"
)
```
